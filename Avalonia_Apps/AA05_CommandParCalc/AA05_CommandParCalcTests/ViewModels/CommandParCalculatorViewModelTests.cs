// ***********************************************************************
// Assembly         : MVVM_05a_CTCommandParCalc_netTests
// Author           : Mir
// Created          : 05-11-2023
//
// Last Modified By : Mir
// Last Modified On : 05-19-2023
// ***********************************************************************
// <copyright file="CommandParCalculatorViewModelTests.cs" company="JC-Soft">
//     Copyright © JC-Soft 2023
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Globalization;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using AA05_CommandParCalc.Data;
using AA05_CommandParCalc.Models;
using AA05_CommandParCalc.Models.Interfaces;
using Avalonia.ViewModels;
using static BaseLib.Helper.TestHelper;
using Avalonia.Views.Extension;
using NSubstitute;
using System.ComponentModel;
using Microsoft.Win32;
using CommunityToolkit.Mvvm.Input;

/// <summary>
/// The Tests namespace.
/// </summary>
/// <autogeneratedoc />
namespace AA05_CommandParCalc.ViewModels.Tests;

/// <summary>
/// Defines test class CommandParCalculatorViewModelTests.
/// Implements the <see cref="BaseTestViewModel" />
/// </summary>
/// <seealso cref="BaseTestViewModel" />
/// <autogeneratedoc />
[TestClass()]
public class CommandParCalculatorViewModelTests : BaseTestViewModel<CommandParCalculatorViewModel>
{
    /// <summary>
    /// The old model
    /// </summary>
    /// <autogeneratedoc />
    private ICalculatorModel? testCalcModel;

    /// <summary>
    /// Initializes this instance.
    /// </summary>
    /// <autogeneratedoc />
    [TestInitialize]
    public override void Init()
    {
        GetModel = () => new CommandParCalculatorViewModel(IoC.GetRequiredService<ICalculatorModel>());
    
        IoC.GetReqSrv = (t) => t switch
        {
            _ when t == typeof(ICalculatorModel) => testCalcModel,
            _ => throw new ArgumentException($"No service for {t}")
        };

        testCalcModel ??= Substitute.For<ICalculatorModel>();
        testCalcModel.Dependencies.Returns( [
        (nameof(ICalculatorModel.canOperator),nameof(ICalculatorModel.Accumulator)),
        (nameof(ICalculatorModel.canOperator),nameof(ICalculatorModel.Register)),
    ]);

        base.Init();
    }

    /// <summary>
    /// Defines the test method CommandParCalculatorViewModelTest.
    /// </summary>
    /// <autogeneratedoc />
    [TestMethod]
    public void CommandParCalculatorViewModelTest()
    {
        Assert.IsNotNull(testModel);
        Assert.IsInstanceOfType(testModel, typeof(ViewModelBase));
        Assert.IsInstanceOfType(testModel, typeof(CommandParCalculatorViewModel));
        Assert.AreEqual(0d, testModel.Accumulator);
        Assert.AreEqual(double.NaN, testModel.Register);
        Assert.AreEqual(double.NaN, testModel.Memory);
        Assert.AreEqual("None Grad ", testModel.Status);
        Assert.AreEqual(false, testModel.canOperator(EOperations.CalcResult));
        Assert.AreEqual(false, testModel.canOperator(EOperations.Add));
        Assert.AreEqual(false, testModel.canCommand(ECommands.DecMode));
        Assert.AreEqual(false, testModel.canCommand(ECommands.MR));
        Assert.IsNotNull(testModel.NumberCommand);
        Assert.IsNotNull(testModel.OperatorCommand);
        Assert.IsNotNull(testModel.CalculatorCommand);
        Assert.AreEqual("", DebugLog);
    }

    /// <summary>
    /// Defines the test method CommandParCalculatorViewModelTest.
    /// </summary>
    /// <autogeneratedoc />
    [TestMethod]
    public void CommandParCalculatorViewModelTest2()
    {
        var testModel3 = new CommandParCalculatorViewModel();
        Assert.IsNotNull(testModel3);
        Assert.IsInstanceOfType(testModel3, typeof(ViewModelBase));
        Assert.IsInstanceOfType(testModel3, typeof(CommandParCalculatorViewModel));
        Assert.AreEqual(0d, testModel3.Accumulator);
        Assert.AreEqual(double.NaN, testModel3.Register);
        Assert.AreEqual(double.NaN, testModel3.Memory);
        Assert.AreEqual("None Grad ", testModel3.Status);
        Assert.AreEqual(false, testModel3.canOperator(EOperations.CalcResult));
        Assert.AreEqual(false, testModel3.canOperator(EOperations.Add));
        Assert.AreEqual(true, testModel3.canCommand(ECommands.DecMode));
        Assert.AreEqual(true, testModel3.canCommand(ECommands.MR));
        Assert.IsNotNull(testModel3.NumberCommand);
        Assert.IsNotNull(testModel3.OperatorCommand);
        Assert.IsNotNull(testModel3.CalculatorCommand);
        Assert.AreEqual("", DebugLog);
    }

    /// <summary>
    /// Accumulators the test.
    /// </summary>
    /// <param name="name">The name.</param>
    /// <param name="adVal">The ad value.</param>
    /// <param name="asExp">As exp.</param>
    /// <autogeneratedoc />
    [DataTestMethod()]
    [DataRow("0", new double[] { 0d }, new string[] { "0", "PropChg(CommandParCalculatorViewModel,Accumulator)=0\r\n" })]
    [DataRow("25", new double[] { 25d }, new string[] { "25", @"PropChg(CommandParCalculatorViewModel,Accumulator)=25
" })]
    [DataRow("PI,E", new double[] { Math.PI, Math.E }, new string[] { "2.718281828459045", @"PropChg(CommandParCalculatorViewModel,Accumulator)=3,141592653589793
PropChg(CommandParCalculatorViewModel,Accumulator)=2,718281828459045
" })]
    [DataRow("Min,NaN,+Inf", new double[] { double.MinValue, double.NaN, double.PositiveInfinity, double.Epsilon }, new string[] { "5E-324", @"PropChg(CommandParCalculatorViewModel,Accumulator)=-1,7976931348623157E+308
PropChg(CommandParCalculatorViewModel,Accumulator)=NaN
PropChg(CommandParCalculatorViewModel,Accumulator)=∞
PropChg(CommandParCalculatorViewModel,Accumulator)=5E-324
" })]

    public void AccumulatorTest(string name, double[] adVal, string[] asExp)
    {
        // Arrange

        // Act    
        foreach (var item in adVal)
        {
            testCalcModel.Accumulator.Returns(item);
            testCalcModel.PropertyChanged += Raise.Event<PropertyChangedEventHandler>(testCalcModel, new PropertyChangedEventArgs(nameof(testCalcModel.Accumulator)));
        }

        // Assert
        Assert.AreEqual(asExp[0], testModel.Accumulator.ToString(CultureInfo.InvariantCulture), "Accumulator");
        Assert.AreEqual(asExp[1], DebugLog, "DebugOut");
    }

    /// <summary>
    /// Registers the test.
    /// </summary>
    /// <param name="name">The name.</param>
    /// <param name="adVal">The ad value.</param>
    /// <param name="asExp">As exp.</param>
    /// <autogeneratedoc />
    [DataTestMethod()]
    [DataRow("0", new double[] { 0d }, new string[] { "0", @"PropChg(CommandParCalculatorViewModel,Register)=0
" })]
    [DataRow("25", new double[] { 25d }, new string[] { "25", @"PropChg(CommandParCalculatorViewModel,Register)=25
" })]
    [DataRow("PI,E", new double[] { Math.PI, Math.E }, new string[] { "2.718281828459045", @"PropChg(CommandParCalculatorViewModel,Register)=3,141592653589793
PropChg(CommandParCalculatorViewModel,Register)=2,718281828459045
" })]
    [DataRow("Min,NaN,+Inf", new double[] { double.MinValue, double.NaN, double.PositiveInfinity, double.Epsilon }, new string[] { "5E-324", @"PropChg(CommandParCalculatorViewModel,Register)=-1,7976931348623157E+308
PropChg(CommandParCalculatorViewModel,Register)=NaN
PropChg(CommandParCalculatorViewModel,Register)=∞
PropChg(CommandParCalculatorViewModel,Register)=5E-324
" })]
    public void RegisterTest(string name, double[] adVal, string[] asExp)
    {
        // Arrange

        // Act    
        foreach (var item in adVal)
        {
            testCalcModel.Register.Returns(item);
            testCalcModel.PropertyChanged += Raise.Event<PropertyChangedEventHandler>(testCalcModel, new PropertyChangedEventArgs(nameof(testCalcModel.Register)));
        }

        // Assert
        Assert.AreEqual(asExp[0], testModel.Register.ToString(CultureInfo.InvariantCulture), "Accumulator");
        Assert.AreEqual(asExp[1], DebugLog, "DebugOut");
    }

    /// <summary>
    /// Memories the test.
    /// </summary>
    /// <param name="name">The name.</param>
    /// <param name="adVal">The ad value.</param>
    /// <param name="asExp">As exp.</param>
    /// <autogeneratedoc />
    [DataTestMethod()]
    [DataRow("0", new double[] { 0d }, new string[] { "0", "PropChg(CommandParCalculatorViewModel,Memory)=0\r\n" })]
    [DataRow("25", new double[] { 25d }, new string[] { "25", @"PropChg(CommandParCalculatorViewModel,Memory)=25
" })]
    [DataRow("PI,E", new double[] { Math.PI, Math.E }, new string[] { "2.718281828459045", @"PropChg(CommandParCalculatorViewModel,Memory)=3,141592653589793
PropChg(CommandParCalculatorViewModel,Memory)=2,718281828459045
" })]
    [DataRow("Min,NaN,+Inf", new double[] { double.MinValue, double.NaN, double.PositiveInfinity, double.Epsilon }, new string[] { "5E-324", @"PropChg(CommandParCalculatorViewModel,Memory)=-1,7976931348623157E+308
PropChg(CommandParCalculatorViewModel,Memory)=NaN
PropChg(CommandParCalculatorViewModel,Memory)=∞
PropChg(CommandParCalculatorViewModel,Memory)=5E-324
" })]
    public void MemoryTest(string name, double[] adVal, string[] asExp)
    {
        // Arrange
        // Act    
        foreach (var item in adVal)
        {
            testCalcModel.Memory.Returns(item);
            testCalcModel.PropertyChanged += Raise.Event<PropertyChangedEventHandler>(testCalcModel, new PropertyChangedEventArgs(nameof(testCalcModel.Memory)));
        }

        // Assert
        Assert.AreEqual(asExp[0], testModel.Memory.ToString(CultureInfo.InvariantCulture), "Accumulator");
        Assert.AreEqual(asExp[1], DebugLog, "DebugOut");
    }

    [DataTestMethod()]
    [DataRow(nameof(CommandParCalculatorViewModel.NumberCommand),ENumbers._7,nameof(ICalculatorModel.NumberCmd))]
    [DataRow(nameof(CommandParCalculatorViewModel.NumberCommand), ENumbers._3, nameof(ICalculatorModel.NumberCmd))]
    [DataRow(nameof(CommandParCalculatorViewModel.OperatorCommand), EOperations.Add, nameof(ICalculatorModel.OperatorCmd))]
    [DataRow(nameof(CommandParCalculatorViewModel.OperatorCommand), EOperations.Square, nameof(ICalculatorModel.OperatorCmd))]
    [DataRow(nameof(CommandParCalculatorViewModel.CalculatorCommand), ECommands.MS, nameof(ICalculatorModel.CalcCmd))]
    [DataRow(nameof(CommandParCalculatorViewModel.CalculatorCommand), ECommands.Nop, nameof(ICalculatorModel.CalcCmd))]
    public void CommandTest(string sCommand,Enum e,string sExp)
    {
        testCalcModel.ClearReceivedCalls();
        // Arrange
        var cmd=typeof(CommandParCalculatorViewModel).GetProperty(sCommand).GetValue(testModel);
        // Act
        if (cmd is IRelayCommand rc)
            rc.Execute(e);
        else
            Assert.Fail("Command not found");

        // Assert
        var exp = testCalcModel.ReceivedCalls().Select(c => c.GetMethodInfo().Name).ToArray();
        Assert.AreEqual(1, exp.Length);
        Assert.AreEqual(sExp, exp[0]);
    }
}
