using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using TileSetAnimator.Models;
using TileSetAnimator.Persistence;

namespace TileSetAnimator.Services;

/// <summary>
/// Generates and parses C# enum source files for tile definitions.
/// </summary>
public sealed class CSharpEnumTileSerializer : ITileEnumSerializer
{
    private static readonly Regex EnumLineRegex = new("^\\s*(?<name>[A-Za-z_][A-Za-z0-9_]*)\\s*(?:=\\s*(?<value>\\d+))?", RegexOptions.Compiled);

    /// <inheritdoc />
    public async Task ExportAsync(IEnumerable<TileDefinition> tiles, string filePath, string enumName, string? namespaceName, CancellationToken cancellationToken = default)
    {
        if (tiles == null)
        {
            throw new ArgumentNullException(nameof(tiles));
        }

        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("File path is required.", nameof(filePath));
        }

        enumName = string.IsNullOrWhiteSpace(enumName) ? "TileDefinitions" : enumName;

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("using System;");
        builder.AppendLine();

        if (!string.IsNullOrWhiteSpace(namespaceName))
        {
            builder.AppendLine($"namespace {namespaceName};");
            builder.AppendLine();
        }

        builder.AppendLine("/// <summary>");
        builder.AppendLine("/// Auto-generated tile identifiers.");
        builder.AppendLine("/// </summary>");
        builder.AppendLine($"public enum {enumName}");
        builder.AppendLine("{");

        var usedNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var tile in tiles.OrderBy(static t => t.Index))
        {
            cancellationToken.ThrowIfCancellationRequested();
            var identifier = CreateIdentifier(tile.Name, tile.Index, usedNames);
            var summary = string.IsNullOrWhiteSpace(tile.Notes)
                ? $"Tile index {tile.Index}"
                : tile.Notes!.Replace('\r', ' ').Replace('\n', ' ');

            builder.AppendLine("    /// <summary>");
            builder.AppendLine($"    /// {summary.Trim()}");
            builder.AppendLine("    /// </summary>");
            builder.AppendLine($"    {identifier} = {tile.Index},");
        }

        builder.AppendLine("}");

        var directory = Path.GetDirectoryName(filePath);
        if (!string.IsNullOrWhiteSpace(directory))
        {
            Directory.CreateDirectory(directory);
        }

        await File.WriteAllTextAsync(filePath, builder.ToString(), Encoding.UTF8, cancellationToken).ConfigureAwait(false);
    }

    /// <inheritdoc />
    public async Task<IReadOnlyList<TileMetadataSnapshot>> ImportAsync(string filePath, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(filePath))
        {
            throw new ArgumentException("File path is required.", nameof(filePath));
        }

        var lines = await File.ReadAllLinesAsync(filePath, cancellationToken).ConfigureAwait(false);
        var snapshots = new List<TileMetadataSnapshot>();
        var commentBuffer = new List<string>();

        foreach (var rawLine in lines)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var line = rawLine.Trim();
            if (line.StartsWith("///", StringComparison.Ordinal))
            {
                var comment = line[3..].Trim();
                comment = StripSummaryTags(comment);
                if (!string.IsNullOrWhiteSpace(comment))
                {
                    commentBuffer.Add(comment);
                }

                continue;
            }

            var match = EnumLineRegex.Match(line);
            if (!match.Success)
            {
                continue;
            }

            var name = match.Groups["name"].Value;
            var valueGroup = match.Groups["value"];
            var index = valueGroup.Success && int.TryParse(valueGroup.Value, out var parsed)
                ? parsed
                : snapshots.Count == 0 ? 0 : snapshots[^1].Index + 1;

            var notes = commentBuffer.Count > 0 ? string.Join(" ", commentBuffer) : null;
            commentBuffer.Clear();

            snapshots.Add(new TileMetadataSnapshot
            {
                Index = index,
                Name = name,
                Notes = notes
            });
        }

        return snapshots;
    }

    private static string StripSummaryTags(string comment)
    {
        if (string.IsNullOrWhiteSpace(comment))
        {
            return string.Empty;
        }

        comment = comment.Replace("<summary>", string.Empty, StringComparison.OrdinalIgnoreCase);
        comment = comment.Replace("</summary>", string.Empty, StringComparison.OrdinalIgnoreCase);
        return comment.Trim();
    }

    private static string CreateIdentifier(string? source, int index, HashSet<string> usedNames)
    {
        if (string.IsNullOrWhiteSpace(source))
        {
            source = $"Tile{index}";
        }

        var builder = new StringBuilder();
        var capitalizeNext = true;
        foreach (var ch in source!)
        {
            if (char.IsLetterOrDigit(ch))
            {
                if (builder.Length == 0 && char.IsDigit(ch))
                {
                    builder.Append('_');
                }

                builder.Append(capitalizeNext ? char.ToUpperInvariant(ch) : ch);
                capitalizeNext = false;
            }
            else if (ch is '_' or '-')
            {
                if (builder.Length == 0)
                {
                    builder.Append('_');
                }
                else if (builder[^1] != '_')
                {
                    builder.Append('_');
                }

                capitalizeNext = true;
            }
            else
            {
                capitalizeNext = true;
            }
        }

        if (builder.Length == 0)
        {
            builder.Append($"Tile{index}");
        }

        var identifier = builder.ToString();
        var suffix = 1;
        while (!usedNames.Add(identifier))
        {
            identifier = $"{builder}_{suffix}";
            suffix++;
        }

        return identifier;
    }
}
