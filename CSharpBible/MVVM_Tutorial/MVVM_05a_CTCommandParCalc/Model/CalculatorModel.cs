// ***********************************************************************
// Assembly         : MVVM_05a_CTCommandParCalc
// Author           : Mir
// Created          : 05-11-2023
//
// Last Modified By : Mir
// Last Modified On : 05-19-2023
// ***********************************************************************
// <copyright file="CalculatorModel.cs" company="JC-Soft">
//     Copyright © JC-Soft 2023
// </copyright>
// <summary></summary>
// ***********************************************************************
using MVVM.ViewModel;
using System;
using System.Collections.Generic;

/// <summary>
/// The Model namespace.
/// </summary>
/// <autogeneratedoc />
namespace MVVM_05a_CTCommandParCalc.Model
{
    /// <summary>
    /// Class CalculatorModel.
    /// Implements the <see cref="NotificationObject" />
    /// Implements the <see cref="MVVM_05a_CTCommandParCalc.Model.ICalculatorModel" />
    /// </summary>
    /// <seealso cref="NotificationObject" />
    /// <seealso cref="MVVM_05a_CTCommandParCalc.Model.ICalculatorModel" />
    /// <autogeneratedoc />
    public class CalculatorModel : NotificationObject, ICalculatorModel
    {

        #region Properties
        /// <summary>
        /// The unary operation
        /// </summary>
        /// <autogeneratedoc />
        private static readonly List<EOperations> _unaryOperation = new() {
            EOperations.Nop,
            EOperations.Negate,
            EOperations.Sin,
            EOperations.Cos,
            EOperations.Tan,
            EOperations.Square,
            EOperations.SquareRt,
            EOperations.Inverse,
            EOperations.ExpN,
            EOperations.LogN,
        };

        /// <summary>
        /// The operation level
        /// </summary>
        /// <autogeneratedoc />
        private static readonly Dictionary<EOperations,int> _OperationLevel = new() {
            { EOperations.CalcResult, 0 },
            { EOperations.Add, 1 },
            { EOperations.Subtract, 1 },
            { EOperations.Multiply, 2 },
            { EOperations.Divide, 2 },
            { EOperations.Power, 3 },
            { EOperations.SquareRtX, 3 },
            };

        /// <summary>
        /// The instance
        /// </summary>
        /// <autogeneratedoc />
        private static CalculatorModel _instance;
        /// <summary>
        /// The op
        /// </summary>
        /// <autogeneratedoc />
        private EOperations _op;
        /// <summary>
        /// The operation
        /// </summary>
        /// <autogeneratedoc />
        private Func<double, double>? _Operation;
        /// <summary>
        /// The accumulator
        /// </summary>
        /// <autogeneratedoc />
        private double _accumulator = 0d;
        /// <summary>
        /// The register
        /// </summary>
        /// <autogeneratedoc />
        private double? _register = null;
        /// <summary>
        /// The memory
        /// </summary>
        /// <autogeneratedoc />
        private double? _memory = null;
        /// <summary>
        /// The stack
        /// </summary>
        /// <autogeneratedoc />
        private Stack<(double, EOperations, Func<double, double>)> _stack = new();
        /// <summary>
        /// The decimal fak
        /// </summary>
        /// <autogeneratedoc />
        private double _decFak;
        /// <summary>
        /// The decimal mode
        /// </summary>
        /// <autogeneratedoc />
        private bool _decMode;
        /// <summary>
        /// The edit mode
        /// </summary>
        /// <autogeneratedoc />
        private bool _editMode;
        /// <summary>
        /// The trig mode
        /// </summary>
        /// <autogeneratedoc />
        private ETrigMode _trigMode;
        /// <summary>
        /// The calculate error
        /// </summary>
        /// <autogeneratedoc />
        private ECalcError _calcError;

        /// <summary>
        /// Gets or sets a value indicating whether [decimal mode].
        /// </summary>
        /// <value><c>true</c> if [decimal mode]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        public bool DecMode
        {
            get => _decMode;
            set
            {
                if (!_decMode && value)
                    _decFak = 1d;
                _decMode = value;
            }
        }

        /// <summary>
        /// Gets or sets the accumulator.
        /// </summary>
        /// <value>The accumulator.</value>
        /// <autogeneratedoc />
        public double Accumulator { get => _accumulator; set => SetProperty(ref _accumulator, value); }
        /// <summary>
        /// Gets or sets the register.
        /// </summary>
        /// <value>The register.</value>
        /// <autogeneratedoc />
        public double? Register { get => _register; set => SetProperty(ref _register, value); }
        /// <summary>
        /// Gets or sets the memory.
        /// </summary>
        /// <value>The memory.</value>
        /// <autogeneratedoc />
        public double? Memory { get => _memory; set => SetProperty(ref _memory, value); }
        /// <summary>
        /// Gets the instance.
        /// </summary>
        /// <value>The instance.</value>
        /// <autogeneratedoc />
        public static CalculatorModel Instance => _instance ??= new();

        /// <summary>
        /// Gets the dependencies.
        /// </summary>
        /// <value>The dependencies.</value>
        /// <autogeneratedoc />
        public IEnumerable<(string, string)> Dependencies => new[]{
            (nameof(canOperator),nameof(Accumulator)),
            (nameof(canOperator),nameof(Register)),
        };


        /// <summary>
        /// Gets the trig mode.
        /// </summary>
        /// <value>The trig mode.</value>
        /// <autogeneratedoc />
        public ETrigMode TrigMode => _trigMode;

        /// <summary>
        /// Gets the calculate error.
        /// </summary>
        /// <value>The calculate error.</value>
        /// <autogeneratedoc />
        public ECalcError CalcError => _calcError;

        /// <summary>
        /// Gets the size of the stack.
        /// </summary>
        /// <value>The size of the stack.</value>
        /// <autogeneratedoc />
        public int StackSize => _stack.Count;

        #endregion

        /// <summary>
        /// Initializes a new instance of the <see cref="CalculatorModel"/> class.
        /// </summary>
        /// <autogeneratedoc />
        public CalculatorModel() { }

        /// <summary>
        /// Determines whether this instance can operator the specified e o.
        /// </summary>
        /// <param name="eO">The e o.</param>
        /// <returns><c>true</c> if this instance can operator the specified e o; otherwise, <c>false</c>.</returns>
        /// <autogeneratedoc />
        public bool canOperator(EOperations eO)
        {
            if (eO == EOperations.Nop) return true;
            if (eO == EOperations.CalcResult) return _Operation != null && _register != null;
            if (eO > EOperations.CalcResult) return _editMode || _accumulator != 0d;
            return false;
        }

        /// <summary>
        /// Determines whether this instance can command the specified e.
        /// </summary>
        /// <param name="e">The e.</param>
        /// <returns><c>true</c> if this instance can command the specified e; otherwise, <c>false</c>.</returns>
        /// <autogeneratedoc />
        public bool canCommand(ECommands e)
        {

            if (e == ECommands.DecMode) return !_decMode;
            return true;
        }


        /// <summary>
        /// Numbers the command.
        /// </summary>
        /// <param name="oo">The oo.</param>
        /// <autogeneratedoc />
        public void NumberCmd(ENumbers oo)
        {
            if (oo is ENumbers e && (int)e is int iN)
            {
                if (!_editMode)
                {
                    _accumulator = 0d;
                    _editMode = true;
                    _decMode = false;
                }
                if (!_decMode)
                    Accumulator = Accumulator * 10d + iN;
                else
                {
                    _decFak *= 0.1d;
                    Accumulator = Accumulator + iN * _decFak;
                }
            }
        }

        /// <summary>
        /// Operators the command.
        /// </summary>
        /// <param name="eO">The e o.</param>
        /// <autogeneratedoc />
        public void OperatorCmd(EOperations eO)
        {

            _editMode = false;

            if (eO >= EOperations.CalcResult && _register != null && !_unaryOperation.Contains(eO))
            {
                if (_Operation != null )
                    Accumulator = _Operation.Invoke(_accumulator);

                Register = null;
                DecMode = false;
            }
            if (eO > EOperations.CalcResult && !_unaryOperation.Contains(eO)) 
            { Register = _accumulator; };
            var op = eO switch
            {

                EOperations.CalcResult => null,
                EOperations.Add => (a) => _register!.Value + a,
                EOperations.Subtract => (a) => _register!.Value - a,
                EOperations.Multiply => (a) => _register!.Value * a,
                EOperations.Divide => (a) => _register!.Value / a,
                EOperations.Power => (a) => Math.Pow(_register!.Value, a),
                EOperations.Negate => (a) => -a,
                EOperations.Square => (a) => a * a,
                EOperations.SquareRt => (a) => Math.Sqrt(a),
                EOperations.Inverse => (a) => 1 / a,
                EOperations.Sin => (a) => Math.Sin(a), // Dodo: Factor by Trig-Mode
                EOperations.Cos => (a) => Math.Cos(a),
                EOperations.Tan => (a) => Math.Tan(a),
                EOperations.LogN => (a) => Math.Log(a),
                EOperations.ExpN => (a) => Math.Exp(a),
                _ => (Func<double, double>?)null,
            };
            if (_unaryOperation.Contains(eO))
                Accumulator = op?.Invoke(_accumulator) ?? _accumulator;
            else
            {
                _op = eO;
                _Operation = op;
            }
        }

        /// <summary>
        /// Calculates the command.
        /// </summary>
        /// <param name="o">The o.</param>
        /// <autogeneratedoc />
        public void CalcCmd(ECommands o)
        {
            switch (o)
            {
                case ECommands.Clear: //Clear  
                    Accumulator = 0d;
                    _editMode = false;
                    break;
                case ECommands.ClearAll: //Clear All  
                    Accumulator = 0d;
                    Register = 0d;
                    _Operation = null;
                    _editMode = false;
                    break;
                case ECommands.DecMode: // DecimalSeparator                          
                    DecMode = true;
                    break;
                case ECommands.e:
                    Accumulator = Math.E;
                    break;
                case ECommands.Pi:
                    Accumulator = Math.PI;
                    break;
                case ECommands.MS: Memory = Accumulator; break;
                case ECommands.MR: Accumulator = Memory ?? 0d; break;
                case ECommands.MC: Memory = null; break;
                case ECommands.Mp: Memory = (Memory ?? 0d) + Accumulator; break;
                case ECommands.Mm: Memory = (Memory ?? 0d) - Accumulator; break;
                default:
                    break;
            }
        }
    }
}
