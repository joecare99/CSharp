// ***********************************************************************
// Assembly         : BaseLib
// Author           : Mir
// Created          : 03-27-2023
//
// Last Modified By : Mir
// Last Modified On : 03-27-2023
// ***********************************************************************
// <copyright file="TypeUtils.cs" company="JC-Soft">
//     Copyright © JC-Soft 2023
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Collections.Generic;
using System.Globalization;

/// <summary>
/// The Helper namespace.
/// </summary>
/// <autogeneratedoc />
namespace BaseLib.Helper;

/// <summary>
/// Class TypeUtils.
/// </summary>
/// <autogeneratedoc />
public static class TypeUtils
{
    /// <summary>
    /// The type dic
    /// </summary>
    /// <autogeneratedoc />
    private static readonly Dictionary<Type, (string name, Func<object?, object?, bool>? compare, Func<object, object> convert)> _typeDic = new(){
        {typeof(int),(nameof(System.Int32),(o1,o2)=>(int?)o1<(int?)o2,
            (o)=>Convert.ToInt32(o)) },
        {typeof(uint),(nameof(System.UInt32),(o1,o2)=>(uint?)o1 < (uint?)o2,
            (o)=>Convert.ToUInt32(o)) },
        {typeof(float),(nameof(System.Single),(o1,o2)=>(float?)o1 < (float?)o2,
            (o)=>Convert.ToSingle(o,CultureInfo.InvariantCulture)) },
        {typeof(double),(nameof(System.Double),(o1,o2)=>(double?)o1 < (double?)o2,
            (o)=>Convert.ToDouble(o,CultureInfo.InvariantCulture)) },
        {typeof(bool),(nameof(System.Boolean),(o1,o2)=>!((bool?)o1??false) && ((bool?)o2??false),
            (o)=>Convert.ToBoolean(o)) },
        {typeof(long),(nameof(System.Int64),(o1,o2)=>(long?)o1 < (long?)o2,
            (o)=>Convert.ToInt64(o)) },
        {typeof(ulong),(nameof(System.UInt64),(o1,o2)=>(ulong?)o1 <(ulong?)o2,
            (o)=>Convert.ToUInt64(o)) },
        {typeof(short),(nameof(System.Int16),(o1,o2)=>(short?)o1 < (short?)o2,
            (o)=>Convert.ToInt16(o)) },
        {typeof(ushort),(nameof(System.Int16),(o1,o2)=>(ushort?)o1 < (ushort?)o2,
            (o)=>Convert.ToUInt16(o)) },
        {typeof(char),(nameof(System.Char),(o1,o2)=>(char?)o1 < (char?)o2,
            (o)=>Convert.ToChar(o)) },
        {typeof(byte),(nameof(System.Byte),(o1,o2)=>(byte?)o1 < (byte?)o2,
            (o)=>Convert.ToByte(o)) },
        {typeof(sbyte),(nameof(System.SByte),(o1,o2)=>(sbyte?)o1 < (sbyte?)o2,
            (o)=>Convert.ToSByte(o)) },
        {typeof(Type),(nameof(System.Type),null,
            (o)=>o is string s? s.ToType(): o is TypeCode e?e.ToType()?? typeof(object): typeof(object)) },
        {typeof(string),(nameof(System.String),null,
            (o)=>Convert.ToString(o,CultureInfo.InvariantCulture)??"") }
        };
    /// <summary>
    /// Tcs the specified type.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <returns>System.TypeCode.</returns>
    /// <autogeneratedoc />
    public static TypeCode TC(this Type? type) => Type.GetTypeCode(type);
    /// <summary>
    /// Converts to type.
    /// </summary>
    /// <param name="tc">The tc.</param>
    /// <returns>System.Type.</returns>
    /// <autogeneratedoc />
    public static Type? ToType(this TypeCode tc) => Type.GetType("System." + tc.ToString(),false,true);

    /// <summary>
    /// Compares the specified type.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <param name="o1">The o1.</param>
    /// <param name="o2">The o2.</param>
    /// <returns>bool.</returns>
    /// <autogeneratedoc />
    public static bool Compare(this Type type, object? o1, object? o2)
        => _typeDic.TryGetValue(type, out var tv) && (tv.compare?.Invoke(o1, o2) ?? false);

    /// <summary>
    /// Gets the specified type.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <param name="o1">The o1.</param>
    /// <returns>object?.</returns>
    /// <autogeneratedoc />
    public static object? Get(this Type type, object? o1)
        => (type.TC(), o1) switch {
            (TypeCode tc, object o) when o.GetType().TC() == tc 
                => o1,
            (_, string s) when string.IsNullOrWhiteSpace(s) && _typeDic.TryGetValue(type,out var tv) 
                => tv.convert.Invoke(0),
            (_, null) when _typeDic.TryGetValue(type, out var tv)
                => tv.convert.Invoke(0),
            (_, _) when _typeDic.TryGetValue(type, out var tv)
                => tv.convert.Invoke(o1!),
            _ => o1
        };

    /// <summary>
    /// Converts to type.
    /// </summary>
    /// <param name="type">The type.</param>
    /// <returns>System.Type.</returns>
    /// <autogeneratedoc />
    public static Type ToType(this string type)
    {
        try
        {
            return Type.GetType($"{(type.Contains(".") ?"":"System.")}{type}", true, true)!;
        }
        catch (Exception)
        {
            return typeof(object);
        }
    }

    /// <summary>
    /// Checks the limit.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="val">The value.</param>
    /// <param name="min">The minimum.</param>
    /// <param name="max">The maximum.</param>
    /// <returns>bool.</returns>
    /// <autogeneratedoc />
    public static bool CheckLimit<T>(this T val, object? min, object? max) where T : struct 
        => !typeof(T).Compare(min, max) 
        || (!typeof(T).Compare(val, min) 
           && !typeof(T).Compare(max, val));

    /// <summary>
    /// Determines whether the specified value is between min & max [incl. end values].
    /// </summary>
    /// <param name="val">The value.</param>
    /// <param name="min">The minimum.</param>
    /// <param name="max">The maximum.</param>
    /// <returns>bool.</returns>
    public static bool IsBetweenIncl(this IComparable val, IComparable min, IComparable max)
        => (min.CompareTo(val) <= 0)
           && (max.CompareTo(val) >=0);
    /// <summary>
    /// Determines whether the specified value is between [excl. ] min & max.
    /// </summary>
    /// <param name="val">The value.</param>
    /// <param name="min">The minimum.</param>
    /// <param name="max">The maximum.</param>
    /// <returns>bool.</returns>
    /// <autogeneratedoc />
    public static bool IsBetweenExcl(this IComparable val, IComparable min, IComparable max)
        => (min.CompareTo(val) < 0)
           && (max.CompareTo(val) > 0);
}
